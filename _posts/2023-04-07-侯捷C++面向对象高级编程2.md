---
layout:     post
title:      "侯捷-C++面向对象高级编程（下）"
date:       2023-04-07 00:00:00
author:     "Gnoy-Nus"
catalog: true
header-img: "img/post-bg-default.jpg"
tags:
    - C++
---

# 转换函数

类中的转换函数，将类对象转换为另一个类型

```c++
class Fraction{
	public:
        operator double() const { //转换函数
            return (double) (m/n);
        }
	private:
		int m,n;
}
Fraction f(2,3);
double d = 4 + f; //编译器自动调用f的转换函数double()

```

## explicit

`non-explicit one argument ctor` 与`转换函数`可能发生歧义

```c++
class Fraction{
	public:
    	Fraction(int num, int den=1):m(num),n(den){} //non-explicit one argument ctor
        operator double() const { //转换函数
            return (double) (m/n);
        }
        Fraction operator+(const Fraction& f) { //重载运算符
                return Fraction(...);
        }
	private:
		int m,n;
}
Fraction f(2,3);
Fraction d = f + 4; //发生歧义:①4被转换为Fraction ②f转为double
Fraction d = 4 + f; //没有歧义
```

所以需要使用`explicit`关键字修饰`单实参构造函数`，表示只能以`显式`的方式进行类型转换

```cpp
explicit Fraction(int num, int den=1):m(num),n(den){}
```

# Pointer-Like Class

智能指针：模拟指针的类（Pointer-Like Class）

```cpp
template<typename T>
class shared_ptr{
	public:
        T& operator*(){  //返回引用
            return *px;
        }
        T* operator->(){ //返回指针，因为->具有传递性，所以sp->method()等同于px->method()
            return px;
        }
        ...
    private:
        T* px;
        ...
}
```

迭代器也有类似的设计

# Function-Like Class

`Functor(仿函数)`：重载`operator ()`的类或结构体，通常会继承奇特的基类

```cpp
template<class T>
struct plus : public binary_function { //Functor
	T operator()(const T& x,const T& y) const { return x+y;} 
}
//使用：auto result = plus()(x,y); //前面的plus()创建临时对象

template<class Arg1,class Arg2,class Result>
struct binary_function{
	typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
}
```



# Member Template成员模板

三种Template：`class template` `function template` `member Template`

例如：`pair`，要求U1类型可转换为T1类型，U2类型可转为T2类型

```cpp
template<class T1,class T1>
struct pair{
     T1 first;
     T2 second;

     template<class U1,class U2> //成员模板，要求U1类型可转换为T1类型，U2类型可转为T2类型
     pair(const pair<U1,U2>& p) : first(p.first), second(p.second) { }
}
```

例如：`智能指针`，因为指针有`up-cast`行为，所以模拟指针的类——智能指针也应该实现这样的特性(通过成员模板实现)

```cpp
Base* ptr = new Derived; //up-cast，用基类的指针指代子类对象
```

```cpp
template<typename _Tp>
class shared_ptr : public _shared_ptr<_Tp>{
	...
	template<typename _Tp1>
	explicit shared_ptr(_Tp1* __p) : _shared_ptr<_Tp>(__p) {} //将Tp1类型的指针转换
}
//使用如下
shared_ptr<Base1> sptr(new Derived); //用子类的指针为参数，获得的是基类的智能指针
```



# 特化（Specialization）

`特化`：泛化的相对面，指将模板中的泛型参数赋予特定的类型

`偏特化`（Partial Specialization）：

​	①个数偏特化：`<T1，T2>` ---> `<bool,T2>`

​	②范围偏特化：`<T>` ---> `<T*>`

# 模板模板参数

模板模板参数：指模板参数为一个模板

```cpp
template<typename T,template<typename T>class Container> //第二个模板参数为模板
class XXX{
	private:
		Container<T> c; //运用模板模板参数Container
        T prop; //运用普通的模板参数T
}
```

```cpp
template<typename T>
using Lst = list<T,allocator<T>>;

XXX<string, list> myclass; //错误，因为list作为模板，有2个模板参数
XXX<string, Lst> myclass; //正确，因为Lst是只有1个模板参数的模板
```

# 三个C++11特性

## variadic templates

个数不定的模板参数，用`...`表示

```cpp
template<typename T,typename... Types> //个数不定的模板参数,typename...表示
void print(const T& firstArg,const Types...& args){ //参数个数不定，Types...表示
	cout<< firstArg<<endl;
	print(args...); //递归调用print处理剩余的参数，args...表示剩余的参数包
    //sizeof...(args)可以获得参数的个数
}
//...：包（pack）
```

## auto

自动推导类型

```cpp
auto i = 6; //自动推导i为整数

//以下写法错误
auto i; 
i=6;
```

## ranged-base for

```cpp
for(auto elem : container){ //container必须为容器，例如vector<int>，{1,2,3,4}
	//elem为值传递，表示容器的元素
}

for(auto& elem : container){ //container必须为容器，例如vector<int>，{1,2,3,4}
	//elem为引用传递，修改elem等同于修改container的元素
}
```



# 引用和函数签名

## 引用变量的大小

指针变量的大小：计算机地址的大小（32位系统则为32位）

引用变量的大小：引用实际为指针，但是具有如下`假象`

`sizeof(引用变量)==sizeof(被引用变量)`

`&引用变量 == &被引用变量`

## 函数签名（signature）

函数签名：`函数名`+`参数`+`const` 

引用不改变函数签名的参数类型

```cpp
double imag(double im) { } //函数①
double imag(double& im) { } //函数②，与函数①的签名相同，会产生歧义
double imag(double im) const { } //函数③，与函数①②的签名不同
```

# 对象模型（ObjectModel）

## 虚函数、虚指针、虚表

对象在内存中拥有`虚指针`，`虚指针`指向`虚表`，`虚表`存储本对象拥有的所有`虚函数地址`

## 动态绑定

`定义`：函数地址在`编译时`就确定，属于`静态绑定`，在`运行时`确定地址属于`动态绑定`

> 在编译的时候编译器并不知道用户选择的是哪种类型的对象。如果不是虚函数,则采用静态绑定,函数体与函数调用在程序运行之前（编译期间）就绑定了。
> 当函数声明为虚函数时,如果使用指针或引用的形式，那么由于指针指向的对象不确定是基类还是派生类，那么编译器就无法采用静态绑定，所以就只有通过动态绑定的方式。因此编译器通过创建一个虚函数表存放虚函数的地址,在运行时,编译器通过虚函数指针在虚函数表中找到正确的函数版本，然后调用。

`总结`：动态绑定三个条件①调用指针或引用 ②该指针是up-cast的（基类指针指向不同的派生类），即调用基类的指针或引用 ③调用虚函数

## 多态

> 多态又分为静态多态和动态多态：
> (1)静态多态，也称为静态绑定或前期绑定(早绑定)：函数重载和函数模板实例化出多个函数（本质也是函数重载）。静态多态也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。
>
> (2)动态多态，也称为动态绑定或后期绑定(晚绑定)：在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，即运行时的多态。在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。
>
> 父类指针或引用指向父类，调用的就是父类的虚函数
> 父类指针或引用指向子类，调用的就是子类的虚函数
>
> [12 C++的多态_c++多态_今天也要写bug、的博客-CSDN博客](https://blog.csdn.net/qq_52670477/article/details/121419019)

# const

COW：Copy On Write写时才拷贝

```cpp
charT operator [](size_type pos) const {//不考虑COW}
reference operator [](size_type pos){//不添加const,考虑COW}
```

规则：当`同时存在`const和non-const版本的成员函数时，(non-)const对象`只能`调用(non-)const版本的函数



# new&delete

## 回顾new和delete的实现过程

注意`new`和`operator new`是不同的，`delete`和`operator delete`是不同的

```cpp
Complex *pc = new Complex; 

//在编译器中实现如下

void* mem = operator new( sizeof(Complex) ); //分配內存，调用malloc
pc = static_cast<Complex*>(mem); //转型
pc->Complex::Complex(1,2); //构造函數
```

```cpp
delete pc;

//在编译器中实现如下

Complex::~Complex(pc); // 析构函數
operator delete(pc); // 释放內存，调用free
```

## 重载`operator new/delete`

目的：实现自主分配内存步骤，进一步可实现例如内存池

### 方式①：全局重载

重载`::operator new` `::operator delete`  `::operator new[] ` `::operator delete[]`

不可以在任何的namespace中声明

```cpp
inline void* operator new(size_t size) //operator new传入需要的内存大小，传回地址
{
	//自定义行为
	return myAlloc(size);
}
inline void* operator new[](size_t size)
{
	//自定义行为
	return myAlloc(size);
}
inline void operator delete(void* ptr) //operator delete传入地址，无返回值
{
	//自定义行为
	myFree(ptr);
}
inline void operator delete[](void* ptr) 
{
	//自定义行为
	myFree(ptr);
}
```

```cpp
void* myAlloc() //自定义分配内存
{
	return malloc(size);
}
void myFree(void* ptr)  //自定义释放内存
{
    return free(ptr);
}
```



### 方式②：类中重载

可以根据不同参数重载，但对`operator new`来说第一个参数必须是`size_t(unsigned_int)`

```cpp
class XXX{
    public:
        void* operator new(size_t size);
        void* operator new(size_t size,char other);
    //根据不同参数重载，除开第一个参数外的参数都是placement argument
}
```

```cpp
Foo* pf = new('c')Foo; //new的小括号里对应的是placement argument
```

不同版本的`operator new`可以写不同版本的`operator delete`，但不会被`delete`调用，只有在new调用构造函数中出现异常时才会调用这些不同版本的`operator delete`

不写对应版本的`operator delete`也不会报错（但可能会警告）

# download

[C++课件_面向对象高级编程2.pdf][1]  

[1]: https://gnoy-nus.github.io/download/C++/C++课件_面向对象高级编程2.pdf